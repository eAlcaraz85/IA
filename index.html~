<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
<!-- 2023-11-07 mar 23:19 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Clasificador en Cascada</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Eduardo Alcaraz" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
<style> #content{max-width:1800px;}</style>
<style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Clasificador en Cascada</h1>
<div id="table-of-contents">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org195d7f5">Ejemplo de clasificación utilizando Haarcascades</a></li>
</ul>
</div>
</div>
<p>
La detección de objetos usando un clasificador en cascada basado en
características de Haar es un método efectivo de detección de objetos
propuesto en 2001 por Paul Viola y Michael Jones en su artículo
"Detección rápida de objetos usando cascada mejorada de
características simples". Este es un método basado en el aprendizaje
automático en el que se entrena una función en cascada a partir de
muchas imágenes positivas y negativas. Luego se usa para detectar
objetos en otras imágenes.
</p>

<p>
El algoritmo requiere una gran cantidad de imágenes positivas
(imágenes faciales) e imágenes negativas (no imágenes faciales) para
entrenar al clasificador. Luego, necesitamos extraer características
de él. Para hacer esto, use la función Haar que se muestra en la
siguiente figura. Son como nuestros núcleos de convolución. Cada
característica es un valor único que se obtiene restando la suma de
píxeles debajo del rectángulo blanco de la suma de píxeles debajo del
rectángulo negro.
</p>


<div class="figure">
<p><img src="img/har.png" alt="har.png" />
</p>
</div>

<p>
Ahora, todos los tamaños y posiciones posibles de cada kernel se
utilizan para calcular muchas funciones. (Imagínese cuántos cálculos
genera. Incluso una ventana de 24x24 generará más de 160.000
características). Para el cálculo de cada característica, necesitamos
encontrar la suma de los píxeles debajo de los rectángulos blanco y
negro. Para resolver este problema, introdujeron la imagen general. No
importa qué tan grande sea su imagen, reducirá el cálculo de un píxel
dado a operaciones que involucren solo cuatro píxeles.
</p>

<p>
Pero de todas estas características que calculamos, la mayoría de
ellas no son relevantes. Por ejemplo, considere la siguiente
figura. La primera fila muestra dos buenas características. La primera
característica elegida pareció centrarse en la naturaleza del área de
los ojos, que generalmente es más oscura que las áreas de la nariz y
las mejillas. La segunda característica elegida se basa en que las
propiedades de los ojos son más oscuras que el puente de la nariz. Sin
embargo, aplicar la misma ventana en las mejillas o en cualquier otro
lugar es irrelevante. Entonces, ¿cómo elegimos la mejor función entre
más de 160.000 funciones?.
</p>


<div class="figure">
<p><img src="img/har2.png" alt="har2.png" />
</p>
</div>


<p>
Para ello, aplicamos todas las funciones a todas las imágenes de
entrenamiento. Para cada característica, encontrará el mejor umbral,
que divide el rostro en positivo y negativo. Obviamente, habrá errores
o clasificaciones erróneas. Elegimos las características con la tasa
de error más baja, lo que significa que son las características más
precisas para clasificar imágenes faciales y no faciales. (Este
proceso no es tan simple. Al principio, el peso de cada imagen es
igual. Después de cada clasificación, el peso de la imagen mal
clasificada aumentará. Luego se realizará el mismo proceso. Se
calculará la nueva tasa de error. También calcular Peso
nuevo. Continúe con este proceso hasta que se alcance la precisión o
la tasa de error requeridas o se encuentre el número requerido de
funciones.
</p>

<p>
El clasificador final es la suma ponderada de estos clasificadores
débiles. Se denomina clasificación débil porque no puede clasificar
imágenes por sí sola, sino que forma un clasificador fuerte junto con
otras clasificaciones. El documento dice que incluso 200 funciones
pueden proporcionar una detección de precisión del 95%. Su
configuración final tiene aproximadamente 6000 funciones. (Imagínese
reducir de más de 160.000 funciones a 6.000 funciones. Esto es una
gran ganancia).
</p>

<p>
Entonces ahora toma una foto. Toma cada ventana de 24x24. Aplicarle
6000 funciones. Busque caras. Vaya &#x2026; ¿No es esto ineficiente y
requiere mucho tiempo? Si. El autor tiene una buena solución para
esto.
</p>

<p>
En la imagen, la mayoría de las imágenes son áreas sin caras. Por lo
tanto, es mejor tener una manera fácil de verificar si la ventana no
es un área frontal. Si no es así, deséchelo todo de una vez y no lo
vuelva a procesar. En cambio, concéntrese en las áreas que pueden
tener caras. De esta forma, dedicaremos más tiempo a comprobar
posibles zonas faciales.
</p>

<p>
Con este fin, introdujeron el concepto de clasificadores en
cascada. En lugar de aplicar los 6000 componentes funcionales a una
ventana, estos componentes funcionales se agrupan en diferentes etapas
de clasificación y se aplican uno por uno. (Por lo general, las
primeras etapas contendrán muy pocas funciones). Si la ventana falla
en la primera etapa, se descarta. No consideramos sus funciones
restantes. Si pasa, se aplica la segunda etapa de la función y el
proceso continúa. La ventana a través de todas las etapas es un área
facial. ¡Qué tal este plan!
</p>

<p>
El detector del autor tiene más de 6000 características con 38 etapas,
con 1, 10, 25, 25 y 50 características en las primeras cinco
etapas. (Las dos funciones en la imagen de arriba son en realidad las
dos mejores funciones obtenidas de Adaboost). Según el autor, cada
subventana evaluó un promedio de 10 características de más de 6000
características.
</p>

<p>
Por lo tanto, esta es una explicación simple e intuitiva del principio
de funcionamiento de la detección de rostros Viola-Jones. Lea este
artículo para obtener más detalles o consulte las referencias en la
sección de otros recursos.
</p>

<div id="outline-container-org195d7f5" class="outline-2">
<h2 id="org195d7f5">Ejemplo de clasificación utilizando Haarcascades</h2>
<div class="outline-text-2" id="text-org195d7f5">
<ul class="org-ul">
<li><a href="https://github.com/opencv/opencv/tree/master/data/haarcascades">Clasificadores Haarcascades de la librería Opencv</a></li>
<li><a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_objdetect/py_face_detection/py_face_detection.html">Tutorial Haarcascades</a></li>
<li><a href="https://docs.opencv.org/2.4/doc/user_guide/ug_traincascade.html">Entrenamiento Haarcascades</a></li>
</ul>


<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">import</span> numpy <span style="color: #51afef;">as</span> np
<span style="color: #51afef;">import</span> cv2 <span style="color: #51afef;">as</span> cv

<span style="color: #DFDFDF;">rostro</span> = cv.CascadeClassifier<span style="color: #51afef;">(</span><span style="color: #7bc275;">'haarcascade_frontalface_alt.xml'</span><span style="color: #51afef;">)</span>
<span style="color: #DFDFDF;">cap</span> = cv.VideoCapture<span style="color: #51afef;">(</span>0<span style="color: #51afef;">)</span>
<span style="color: #DFDFDF;">x</span>=<span style="color: #DFDFDF;">y</span>=<span style="color: #DFDFDF;">w</span>=<span style="color: #DFDFDF;">h</span>= 0 
<span style="color: #DFDFDF;">img</span> = 0
<span style="color: #DFDFDF;">count</span> = 0
<span style="color: #51afef;">while</span> <span style="color: #a991f1;">True</span>:
    <span style="color: #DFDFDF;">ret</span>, <span style="color: #DFDFDF;">frame</span> = cap.read<span style="color: #51afef;">()</span>
    <span style="color: #DFDFDF;">gray</span> = cv.cvtColor<span style="color: #51afef;">(</span>frame, cv.COLOR_BGR2GRAY<span style="color: #51afef;">)</span>
    <span style="color: #DFDFDF;">rostros</span> = rostro.detectMultiScale<span style="color: #51afef;">(</span>gray, 1.3, 5<span style="color: #51afef;">)</span>
    <span style="color: #51afef;">for</span><span style="color: #51afef;">(</span>x, y, w, h<span style="color: #51afef;">)</span> <span style="color: #51afef;">in</span> rostros:
        <span style="color: #DFDFDF;">m</span>= <span style="color: #C57BDB;">int</span><span style="color: #51afef;">(</span>h/2<span style="color: #51afef;">)</span>
        <span style="color: #DFDFDF;">frame</span> = cv.rectangle<span style="color: #51afef;">(</span>frame, <span style="color: #C57BDB;">(</span>x,y<span style="color: #C57BDB;">)</span>, <span style="color: #C57BDB;">(</span>x+w, y+h<span style="color: #C57BDB;">)</span>, <span style="color: #C57BDB;">(</span>0, 255, 0<span style="color: #C57BDB;">)</span>, 2<span style="color: #51afef;">)</span>
        <span style="color: #DFDFDF;">frame</span> = cv.rectangle<span style="color: #51afef;">(</span>frame, <span style="color: #C57BDB;">(</span>x,y+m<span style="color: #C57BDB;">)</span>, <span style="color: #C57BDB;">(</span>x+w, y+h<span style="color: #C57BDB;">)</span>, <span style="color: #C57BDB;">(</span>255, 0 ,0<span style="color: #C57BDB;">)</span>, 2 <span style="color: #51afef;">)</span>
        <span style="color: #DFDFDF;">img</span> = 180- frame<span style="color: #51afef;">[</span>y:y+h,x:x+w<span style="color: #51afef;">]</span>
        <span style="color: #DFDFDF;">count</span> = count + 1   
    
    <span style="color: #62686E;">#</span><span style="color: #62686E;">name = '/home/likcos/imgs/cara'+str(count)+'.jpg'</span>
    <span style="color: #62686E;">#</span><span style="color: #62686E;">cv.imwrite(name, frame)</span>
    cv.imshow<span style="color: #51afef;">(</span><span style="color: #7bc275;">'rostros'</span>, frame<span style="color: #51afef;">)</span>
    cv.imshow<span style="color: #51afef;">(</span><span style="color: #7bc275;">'cara'</span>, img<span style="color: #51afef;">)</span>
    
    <span style="color: #DFDFDF;">k</span> = cv.waitKey<span style="color: #51afef;">(</span>1<span style="color: #51afef;">)</span>
    <span style="color: #51afef;">if</span> k == 27:
        <span style="color: #51afef;">break</span>
cap.release<span style="color: #51afef;">()</span>
cv.destroyAllWindows<span style="color: #51afef;">()</span>
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Autor: Eduardo Alcaraz</p>
<p class="date">Created: 2023-11-07 mar 23:19</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
